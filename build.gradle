plugins {
    id "com.github.hierynomus.license" version "0.14.0"
    id 'net.researchgate.release' version '2.6.0'
    id "org.sonarqube" version "2.5"
    id 'org.unbroken-dome.test-sets' version '1.4.2'
    id 'com.github.psxpaul.execfork' version '0.1.5'
    id 'io.spring.dependency-management' version '1.0.3.RELEASE'
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'maven'
apply plugin: 'maven-publish'
apply plugin: 'checkstyle'
apply plugin: "jacoco"
apply plugin: 'findbugs'
apply plugin: 'pmd'
apply plugin: 'license'
apply plugin: 'signing'
apply plugin: 'project-report'
apply plugin: 'build-dashboard'
apply plugin: 'net.researchgate.release'
apply plugin: 'io.spring.dependency-management'

archivesBaseName = 'spring-cloud-ribbon-extensions'
group = 'com.github.enadim'
sourceCompatibility = 1.8
targetCompatibility = 1.8

ext {
    jcenterUrl = project.hasProperty('customJcenterUrl') ? project.customJcenterUrl : 'https://jcenter.bintray.com/'
    mavenUrl = project.hasProperty('customMavenUrl') ? project.customMavenUrl : 'https://repo.maven.apache.org/maven2/'
    mavenPluginsUrl = project.hasProperty('customMavenPluginsUrl') ? project.customMavenPluginsUrl : 'https://plugins.gradle.org/m2/'

    jvm = org.gradle.internal.jvm.Jvm.current()
    javaDescription = '' + jvm
    javaVersion = '' + JavaVersion.current()

    projectUrl = 'https://github.com/enadim/' + archivesBaseName
    projectDescription = 'Netflix ribbon extensions.'
    projectScmUrl = 'scm:git:' + projectUrl + '.git'

    licenseName = 'The Apache License, Version 2.0'
    licenseUrl = 'http://www.apache.org/licenses/LICENSE-2.0.txt'

    authorId = 'enadim'
    authorName = 'Nadim Benabdenbi'
    authorEmail = 'nadim.benabdenbi@gmail.com'

    gitCommitId = 'git rev-parse HEAD'.execute().text.trim()
    gitBranchName = 'git name-rev --name-only HEAD'.execute().text.trim()
    isReleaseVersion = !version.endsWith("SNAPSHOT")
}

task wrapper(type: Wrapper) {
    gradleVersion = '4.3'
}

repositories {
    jcenter {
        url jcenterUrl
    }
    mavenLocal()
    maven {
        url mavenUrl
    }
}

dependencyManagement {
    imports {
        mavenBom 'org.springframework.cloud:spring-cloud-netflix:1.3.2.RELEASE'
        mavenBom 'org.springframework.boot:spring-boot:1.5.6.RELEASE'
    }
}

dependencies {
    compileOnly 'org.projectlombok:lombok:1.16.16'
    compileOnly 'com.google.code.findbugs:annotations:3.0.1'

    compile("org.springframework.boot:spring-boot-starter-activemq") { ext.optional = true }
    compile("org.apache.activemq:activemq-broker")                   { ext.optional = true }
    compile("com.fasterxml.jackson.core:jackson-databind")           { ext.optional = true }
    compile('org.springframework.cloud:spring-cloud-starter-ribbon') { ext.optional = true }
    compile('org.springframework.cloud:spring-cloud-starter-feign')  { ext.optional = true}
    compile('org.springframework.cloud:spring-cloud-starter-eureka') { ext.optional = true}
    compile('org.springframework.cloud:spring-cloud-starter-eureka') { ext.optional = true}
    compile('org.springframework.cloud:spring-cloud-starter-eureka-server') {
        exclude group: 'javax.servlet', module: 'servlet-api'
        ext.optional = true
    }

    testCompileOnly 'org.projectlombok:lombok:1.16.16'
    testCompile 'org.springframework.cloud:spring-cloud-starter-zuul'
    testCompile 'org.springframework.boot:spring-boot-starter-web'
    testCompile 'org.springframework.boot:spring-boot-test'
    testCompile 'org.springframework.boot:spring-boot-starter-test'
    testCompile 'org.mockito:mockito-core:2.11.0'
    testCompile 'net.bytebuddy:byte-buddy:1.7.4'
    testCompile 'io.rest-assured:rest-assured:3.0.3'
}

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}

eclipse {
    classpath {
        downloadSources=true
    }
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

jar {
    manifest {
        attributes (
                'Implementation-Title': archivesBaseName,
                'Implementation-Version': version,
                'Bundle-Name': archivesBaseName,
                'Bundle-Version': version,
                'Bundle-Description': projectDescription,
                'Created-By': javaDescription,
                'License': licenseName,
                'Build-Jdk': javaVersion,
                'Build-Date': new Date().format('yyyy-MM-dd HH:mm:ss.SSS', TimeZone.getTimeZone('UTC')),
                'Gradle-Version': gradle.gradleVersion,
                'Module-Url': projectUrl,
                'Module-Owner': authorName,
                'Module-Owner-Email': authorEmail,
                'Module-Branch': gitBranchName,
                'Module-Commit': gitCommitId)
    }
}

checkstyle {
    sourceSets = [project.sourceSets.main]
    toolVersion "8.4"
}
tasks.withType(Checkstyle) {
    reports {
        xml.enabled false
        html.enabled true
    }
}
check.dependsOn checkstyleMain

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

task testSourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'testSources'
    from sourceSets.test.allSource
}

task testJar(type: Jar, dependsOn: testClasses) {
    classifier = 'tests'
    from sourceSets.test.output
}

assemble.dependsOn projectReport
assemble.dependsOn testJar
assemble.dependsOn testSourcesJar

artifacts {
    archives javadocJar, sourcesJar, testSourcesJar, testJar
}

signing {
    required { isReleaseVersion || gradle.taskGraph.hasTask("uploadArchives")}
    sign configurations.archives
}


license {
    mapping {
        java = 'SLASHSTAR_STYLE'
    }
    header rootProject.file('HEADER')
    strictCheck true
    include '**/*.java'
    ext.year = Calendar.getInstance().get(Calendar.YEAR)
}

compileJava {
    options.fork = true
}

findbugs {
    sourceSets = [sourceSets.main]
    ignoreFailures = project.hasProperty('ignoreFailures')
    reportLevel = 'low'
}

tasks.withType(FindBugs) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

pmd {
    sourceSets = [sourceSets.main]
    ignoreFailures = project.hasProperty('ignoreFailures')
}

jacocoTestReport {
    reports {
        xml.enabled = true
        html.enabled = true
    }
}
projectReport.dependsOn jacocoTestReport

jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'CLASS'
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 1.0
            }
            limit {
                counter = 'BRANCH'
                value = 'COVEREDRATIO'
                minimum = 1.0
            }
            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 1.0
            }
            limit {
                counter = 'COMPLEXITY'
                value = 'COVEREDRATIO'
                minimum = 1.0
            }
            limit {
                counter = 'CLASS'
                value = 'MISSEDCOUNT'
                maximum = 0
            }
        }
    }
}
if (!project.hasProperty('ignoreFailures')){
    check.dependsOn jacocoTestCoverageVerification
}

testSets {
    integrationTest {
        dirName = 'it'
        createArtifact = true
    }
}

task eureka(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.eureka.EurekaApplication'
    classpath = sourceSets.test.runtimeClasspath
    workingDir = "$buildDir"
    standardOutput = "$buildDir/eureka.log"
    errorOutput = "$buildDir/eureka-error.log"
    waitForPort = 8000
    timeout = 30
}

task application11(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.application1.Application1'
    classpath = sourceSets.test.runtimeClasspath
    args = ['--spring.config.name=application11']
    workingDir = "$buildDir"
    standardOutput = "$buildDir/application11.log"
    errorOutput = "$buildDir/application11-error.log"
    waitForPort = 8011
    timeout = 30
}
application11.dependsOn eureka

task application12(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.application1.Application1'
    classpath = sourceSets.test.runtimeClasspath
    args = ['--spring.config.name=application12']
    workingDir = "$buildDir"
    standardOutput = "$buildDir/application12.log"
    errorOutput = "$buildDir/application12-error.log"
    waitForPort = 8012
    timeout = 30
}
application12.dependsOn eureka

task application21(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.application2.Application2'
    classpath = sourceSets.test.runtimeClasspath
    args = ['--spring.config.name=application21']
    workingDir = "$buildDir"
    standardOutput = "$buildDir/application21.log"
    errorOutput = "$buildDir/application21-error.log"
    waitForPort = 8021
    timeout = 30
}

application21.dependsOn eureka
task application22(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.application2.Application2'
    classpath = sourceSets.test.runtimeClasspath
    args = ['--spring.config.name=application22']
    workingDir = "$buildDir"
    standardOutput = "$buildDir/application22.log"
    errorOutput = "$buildDir/application22-error.log"
    waitForPort = 8022
    timeout = 30
}
application22.dependsOn eureka

task zuul(type: com.github.psxpaul.task.JavaExecFork) {
    main = 'com.github.enadim.spring.cloud.ribbon.it.zuul.ZuulApplication'
    classpath = sourceSets.test.runtimeClasspath
    workingDir = "$buildDir"
    standardOutput = "$buildDir/zuul.log"
    errorOutput = "$buildDir/zuul-error.log"
    waitForPort = 8001
    timeout = 30
}
zuul.dependsOn eureka
zuul.dependsOn application11
zuul.dependsOn application12
zuul.dependsOn application21
zuul.dependsOn application22

if (project.hasProperty('it')) {
    integrationTest.dependsOn zuul
    integrationTest.mustRunAfter test
    check.dependsOn integrationTest
    project.tasks["sonarqube"].dependsOn "integrationTest"
} else {
    project.tasks["sonarqube"].dependsOn "test"
}

test {
    ignoreFailures = project.hasProperty('ignoreFailures')
}
integrationTest {
    ignoreFailures = project.hasProperty('ignoreFailures')
}

uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
            repository(url: 'https://oss.sonatype.org/service/local/staging/deploy/maven2/') {
                authentication( userName: rootProject.hasProperty('ossrhUsername') ? rootProject.ossrhUsername : '', password: rootProject.hasProperty('ossrhPassword') ? rootProject.ossrhPassword : '')
            }
            snapshotRepository(url: 'https://oss.sonatype.org/content/repositories/snapshots/') {
                authentication( userName: rootProject.hasProperty('ossrhUsername') ? rootProject.ossrhUsername : '', password: rootProject.hasProperty('ossrhPassword') ? rootProject.ossrhPassword : '')
            }
            pom.project {
                name archivesBaseName
                packaging 'jar'
                description projectDescription
                url projectUrl
                scm {
                    connection projectScmUrl
                    developerConnection projectScmUrl
                    url projectScmUrl
                }
                licenses {
                    license {
                        name licenseName
                        url licenseUrl
                    }
                }
                developers {
                    developer {
                        id authorId
                        name authorName
                        email authorEmail
                    }
                }
            }
        }
    }
}

def installer = install.repositories.mavenInstaller
def deployer = uploadArchives.repositories.mavenDeployer

[installer, deployer]*.pom*.whenConfigured { pom ->
    def dependencyMap = project.configurations.compile.dependencies.collectEntries { [it.name, it] }
    pom.dependencies.findAll {
        def dep = dependencyMap[it.artifactId]
        return dep?.hasProperty('optional') && dep.optional
    }*.optional = true
}

release{
    git {
        requireBranch = ''
    }
    //pushChanges = false
}
class ReplaceVersionInFile extends DefaultTask {
    @Input
    String fileName
    @TaskAction
    def build() {
        def newVersion = ''
        new File('gradle.properties').eachLine { line ->
            if( newVersion.isEmpty() && line.startsWith('version=')){
                newVersion = line.substring('version='.length())
            }
        }
        println 'Setting new version ' + newVersion + ' on file ' + fileName
        def file = new File(fileName)
        def newContent = file.text.replaceAll('[0-9]+\\.[0-9]+\\.[0-9]+(-SNAPSHOT)?', newVersion)
        file.text = newContent
    }
}
class ReadMeBranch extends DefaultTask {
    @Input
    String targetBranch
    @TaskAction
    def build() {
        println 'README.md: switching branch to ' + targetBranch
        def content = ''
        def readmeBranch = ''
        def readme = new File('README.md')
        readme.eachLine { line ->
            if( readmeBranch.isEmpty() && line.contains('branch=')){
                readmeBranch = line.substring(line.indexOf('branch=')+'branch='.length())
                readmeBranch = readmeBranch.substring(0,readmeBranch.indexOf(')'))
             }
        }
        readme = new File('README.md')
        readme.eachLine { line ->
            if(line.startsWith('[![')){
                content += line.replaceAll(readmeBranch,targetBranch) + '\n'
            }else{
                content += line + '\n'
            }
        }
        readme.text = content
    }
}
task updateReadMeProjectReleaseVersion(type: ReplaceVersionInFile){
    fileName = 'README.md'
}
task updateSonarProjectReleaseVersion(type: ReplaceVersionInFile){
    fileName = 'sonar-project.properties'
}
task updateReadMeProjectVersion(type: ReplaceVersionInFile){
    fileName = 'README.md'
}
task updateSonarProjectVersion(type: ReplaceVersionInFile){
    fileName = 'sonar-project.properties'
}
task ReadMeForMaster(type:ReadMeBranch){
    targetBranch =  'master'
}
task ReadMeForCurrent(type:ReadMeBranch){
    targetBranch = gitBranchName
}
commitNewVersion.dependsOn ReadMeForCurrent
commitNewVersion.dependsOn updateSonarProjectVersion
commitNewVersion.dependsOn updateReadMeProjectVersion
runBuildTasks.dependsOn ReadMeForMaster
runBuildTasks.dependsOn updateReadMeProjectReleaseVersion
runBuildTasks.dependsOn updateSonarProjectReleaseVersion
afterReleaseBuild.dependsOn uploadArchives
